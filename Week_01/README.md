# JVM核心技术----基础知识

## 1.字节码
字节码的本质是java代码编译后的，给jvm虚拟机运行的操作指令。
> Java bytecode 由单字节(byte)的指令组成，理论上最多支持 256 个操作码(opcode)。 实际上 Java 只使用了200左右的操作码， 还有一些操作码则保留给调试操作。
> 根据指令的性质，主要分为四个大类:
> 1. 栈操作指令，包括与局部变量交互的指令 2. 程序流程控制指令
> 3. 对象操作指令，包括方法调用指令
> 4. 算术运算以及类型转换指令

可通过 `javac Hello.java`获取这个类的.class字节码文件。
默认不带附加信息，如果要编译带调试信息则加参数-g：`javac -g Hello.java` 
查看字节码:`javap -c Hello.java`
如果要查看常量池等：`javap -c -verbose Hello.java`
### 字节码阅读：
`0: new #2`
表示的是本块代码的第一个指令是new 一个常量池里的第二个常量代表的类型的实例。其中new的操作码二进制是bb，操作数是2，那么用二进制表示这条指令就是3个字节：bb 00 02，补上一个00是因为new后面跟两个操作数。
### 目的
1）了解底层jvm执行的是什么，可以用来分析不同代码是否是等价的，如果不等价哪个方式更好。
比如for循环里用i++还是for(i:数组) 。通过课上的演示，我们知道他们是等价的。（大家想想，如果for : 里不是数组，而是list，字节码会怎么样？）
比如String a = "a" + "b"; String c = a + "c"; 通过字节码分析，我们知道：编译后"a" + "b"直接变成了“ab”，相当于 a =“ab”；字符串String作为一个类，是不能做+操作的，所以在字节码层面，都转换成了StringBuilder的append操作，上面的代码相当于String c = new StringBuilder().append("ab").append("c").toString(); 
2）后面学习AOP的时候，有一大块是字节码操作和增强，这里的内容是那一部分的基础。

## 2.类加载器（☆重点）
类加载器负责把字节码文件或字节码的byte[]转换成为jvm中的类。
> 类的加载时机
> 1. 当虚拟机启动时，初始化用户指定的主类，就是启动执行的 main 方法所在的类;
> 2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类，就是 new 一个类的时候要初始化;
> 3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类;
> 4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类;
> 5. 子类的初始化会触发父类的初始化;
> 6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化， 会触发该接口的初始化;
> 7. 使用反射 API 对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射调用 要么是已经有实例了，要么是静态方法，都需要初始化;
> 8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的 类。

![classloader](https://i.loli.net/2021/01/10/GVhP76ZQNKxWDbn.png)

注意：
1.JDK9里扩展类加载器和应用类加载器，不再继承URLClassLoader。但是可以这些主动加载： Class.forName("xxx", new URLClassloader("dddd"));
2.jdk代码里写死了，不允许自定义classloader加载以java.开头包名的类。

> 可以实现自定义classloader，做加密、混淆等，保护我们的jar包不被反编译和破解；实际上通过自定义classloader，我们在类加载到jvm的时候可以做一些额外的处理.
> 早期实现动态加载，模块化都是基于自定义classloader的，如果我们实现两个自定义classloader，比如A和B，他们没有关系，且各自加载了一个叫Hello的类，这两个Hello的类型是不同的，这样就可以实现不同版本的类隔离（如果代码写的不恰当，也可能会出现所谓A的一个Hello类的实例，运行时做类型转换无法转换成B的Hello类型的错误）；

### 3.Java内存模型（☆重点）
类被加载到JVM中，代码运行时都需要使用内存，所以Java内存模型就是用来规定JVM内部的内存结构。

> 每个线程都只能访问自己的线程栈。
> 每个线程都不能访问(看不见)其他线程的局部变 量。
> 所有原生类型的局部变量都存储在线程栈中，因此 对其他线程是不可见的。
> 线程可以将一个原生变量值的副本传给另一个线程， 但不能共享原生局部变量本身。
> 堆内存中包含了 Java 代码中创建的所有对象，不 管是哪个线程创建的。 其中也涵盖了包装类型 (例如 Byte，Integer，Long 等)。
> 不管是创建一个对象并将其赋值给局部变量， 还 是赋值给另一个对象的成员变量， 创建的对象都 会被保存到堆内存中。

#### JVM内存结构
![JVM structure1](https://i.loli.net/2021/01/10/OZESNoLzMqT6vkP.png)
* 方法中使用的原生数据类型和对象引用地址在栈上存储; 对象、对象成员与类定义、静态变量在堆上。
* 堆内存又称为“共享堆”，堆中的所有对象，可以被所有线程访问, 只要他们能拿到对象的引用地址。
* 如果一个线程可以访问某个对象时， 也就可以访问该对象的成员变量。
* 如果两个线程同时调用某个对象的同一方法，则它们都可以访问到这个对象的成员变量，但每个线程的局部变量副本是独立的。

#### JVM 内存整体结构
![JVM structure2](https://i.loli.net/2021/01/10/yvF1aj5MOnpGrwh.png)

* 每启动一个线程，JVM就会在栈空间栈分配对应的线程栈, 比如 1MB 的空间(-Xss1m)。
* 线程栈也叫做 Java 方法栈。 如果使用了JNI方法，则会分配一个单独的本地方法栈 (Native Stack)。
* 线程执行过程中，一般会有多个方法组成调用栈(Stack Trace), 比如A调用B,B调用C...每执行到一个方法,就会创建对应的栈帧(Frame)。

#### JVM 堆内存结构
![JVM structure3](https://i.loli.net/2021/01/10/dEwzrZ4lx1h7GFP.png)
* 堆内存是所有线程共用的内存空间，JVM 将 Heap 内存分为年轻代(Young generation)和 老年代(Old generation, 也叫Tenured)两部分。
* 年轻代还划分为 3 个内存池，新生代(Eden space)和存活区(Survivor space), 在大部分 GC 算法中有 2 个存活区(S0, S1)，在我们可以观察到的任何时刻，S0 和 S1 总有一个是空的, 但一般较小，也不浪费多少空间。
* Non-Heap 本质上还是 Heap，只是一般不归 GC 管理，里面划分为 3 个内存池。
* Metaspace, 以前叫持久代(永久代, Permanent generation), Java8 换了个名字叫 Metaspace.
* CCS, Compressed Class Space, 存放 class 信息的，和 Metaspace 有交叉。
* Code Cache, 存放 JIT 编译器编译后的本地机器代码。

### 4.JVM 启动参数
JVM作为一个通用的虚拟计算机，是通过java命令来启动的，为了让JVM能够适应不同的需求环境，所以需要配置不同的参数使JVM更好的工作，这就是java命令执行的命令行参数。

以-开头为标准参数，所有的 JVM 都要实现这些参 数，并且向后兼容。
-D 设置系统属性。
以 -X 开头为非标准参数， 基本都是传给 JVM 的， 默认 JVM 实现这些参数的功能，但是并不保证所 有 JVM 实现都满足，且不保证向后兼容。 可以使 用 java -X 命令来查看当前 JVM 支持的非标准参 数。
以 –XX:开头为非稳定参数, 专门用于控制 JVM 的行为，跟具体的 JVM 实现有关，随时可能会在 下个版本取消。
-XX:+-Flags 形式, +- 是对布尔值进行开关。 -XX:key=value 形式, 指定某个选项的值。

> 常用的命令行参数有哪些？
> 标准参数 -server
> 非标准参数 -Xmx，-XX：xxxx=yyyy
> 系统属性-Dxxx=yyy

![JVM initial  heap parameter](https://i.loli.net/2021/01/10/qaMnH9dk1XUxvwP.png)

jvm内存配置经验：xmx ~ 不要超过系统可用内存的60-80%
例如 系统有4g可用内存 -> 4g*0.6~0.8 -> 可以设置xmx为2.4~3.2g



